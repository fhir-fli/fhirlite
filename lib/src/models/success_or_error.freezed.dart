// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'success_or_error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FhirliteSuccess {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() success,
    required TResult Function(String value) successString,
    required TResult Function(bool value) successBool,
    required TResult Function(NotificationResult value)
        successNotificationResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? success,
    TResult? Function(String value)? successString,
    TResult? Function(bool value)? successBool,
    TResult? Function(NotificationResult value)? successNotificationResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? success,
    TResult Function(String value)? successString,
    TResult Function(bool value)? successBool,
    TResult Function(NotificationResult value)? successNotificationResult,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Successful value) success,
    required TResult Function(SuccessString value) successString,
    required TResult Function(SuccessBool value) successBool,
    required TResult Function(SuccessNotificationResult value)
        successNotificationResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Successful value)? success,
    TResult? Function(SuccessString value)? successString,
    TResult? Function(SuccessBool value)? successBool,
    TResult? Function(SuccessNotificationResult value)?
        successNotificationResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Successful value)? success,
    TResult Function(SuccessString value)? successString,
    TResult Function(SuccessBool value)? successBool,
    TResult Function(SuccessNotificationResult value)?
        successNotificationResult,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FhirliteSuccessCopyWith<$Res> {
  factory $FhirliteSuccessCopyWith(
          FhirliteSuccess value, $Res Function(FhirliteSuccess) then) =
      _$FhirliteSuccessCopyWithImpl<$Res, FhirliteSuccess>;
}

/// @nodoc
class _$FhirliteSuccessCopyWithImpl<$Res, $Val extends FhirliteSuccess>
    implements $FhirliteSuccessCopyWith<$Res> {
  _$FhirliteSuccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SuccessfulImplCopyWith<$Res> {
  factory _$$SuccessfulImplCopyWith(
          _$SuccessfulImpl value, $Res Function(_$SuccessfulImpl) then) =
      __$$SuccessfulImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuccessfulImplCopyWithImpl<$Res>
    extends _$FhirliteSuccessCopyWithImpl<$Res, _$SuccessfulImpl>
    implements _$$SuccessfulImplCopyWith<$Res> {
  __$$SuccessfulImplCopyWithImpl(
      _$SuccessfulImpl _value, $Res Function(_$SuccessfulImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SuccessfulImpl implements Successful {
  const _$SuccessfulImpl();

  @override
  String toString() {
    return 'FhirliteSuccess.success()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SuccessfulImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() success,
    required TResult Function(String value) successString,
    required TResult Function(bool value) successBool,
    required TResult Function(NotificationResult value)
        successNotificationResult,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? success,
    TResult? Function(String value)? successString,
    TResult? Function(bool value)? successBool,
    TResult? Function(NotificationResult value)? successNotificationResult,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? success,
    TResult Function(String value)? successString,
    TResult Function(bool value)? successBool,
    TResult Function(NotificationResult value)? successNotificationResult,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Successful value) success,
    required TResult Function(SuccessString value) successString,
    required TResult Function(SuccessBool value) successBool,
    required TResult Function(SuccessNotificationResult value)
        successNotificationResult,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Successful value)? success,
    TResult? Function(SuccessString value)? successString,
    TResult? Function(SuccessBool value)? successBool,
    TResult? Function(SuccessNotificationResult value)?
        successNotificationResult,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Successful value)? success,
    TResult Function(SuccessString value)? successString,
    TResult Function(SuccessBool value)? successBool,
    TResult Function(SuccessNotificationResult value)?
        successNotificationResult,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class Successful implements FhirliteSuccess {
  const factory Successful() = _$SuccessfulImpl;
}

/// @nodoc
abstract class _$$SuccessStringImplCopyWith<$Res> {
  factory _$$SuccessStringImplCopyWith(
          _$SuccessStringImpl value, $Res Function(_$SuccessStringImpl) then) =
      __$$SuccessStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$SuccessStringImplCopyWithImpl<$Res>
    extends _$FhirliteSuccessCopyWithImpl<$Res, _$SuccessStringImpl>
    implements _$$SuccessStringImplCopyWith<$Res> {
  __$$SuccessStringImplCopyWithImpl(
      _$SuccessStringImpl _value, $Res Function(_$SuccessStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SuccessStringImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuccessStringImpl implements SuccessString {
  const _$SuccessStringImpl(this.value);

  @override
  final String value;

  @override
  String toString() {
    return 'FhirliteSuccess.successString(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessStringImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessStringImplCopyWith<_$SuccessStringImpl> get copyWith =>
      __$$SuccessStringImplCopyWithImpl<_$SuccessStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() success,
    required TResult Function(String value) successString,
    required TResult Function(bool value) successBool,
    required TResult Function(NotificationResult value)
        successNotificationResult,
  }) {
    return successString(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? success,
    TResult? Function(String value)? successString,
    TResult? Function(bool value)? successBool,
    TResult? Function(NotificationResult value)? successNotificationResult,
  }) {
    return successString?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? success,
    TResult Function(String value)? successString,
    TResult Function(bool value)? successBool,
    TResult Function(NotificationResult value)? successNotificationResult,
    required TResult orElse(),
  }) {
    if (successString != null) {
      return successString(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Successful value) success,
    required TResult Function(SuccessString value) successString,
    required TResult Function(SuccessBool value) successBool,
    required TResult Function(SuccessNotificationResult value)
        successNotificationResult,
  }) {
    return successString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Successful value)? success,
    TResult? Function(SuccessString value)? successString,
    TResult? Function(SuccessBool value)? successBool,
    TResult? Function(SuccessNotificationResult value)?
        successNotificationResult,
  }) {
    return successString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Successful value)? success,
    TResult Function(SuccessString value)? successString,
    TResult Function(SuccessBool value)? successBool,
    TResult Function(SuccessNotificationResult value)?
        successNotificationResult,
    required TResult orElse(),
  }) {
    if (successString != null) {
      return successString(this);
    }
    return orElse();
  }
}

abstract class SuccessString implements FhirliteSuccess {
  const factory SuccessString(final String value) = _$SuccessStringImpl;

  String get value;
  @JsonKey(ignore: true)
  _$$SuccessStringImplCopyWith<_$SuccessStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessBoolImplCopyWith<$Res> {
  factory _$$SuccessBoolImplCopyWith(
          _$SuccessBoolImpl value, $Res Function(_$SuccessBoolImpl) then) =
      __$$SuccessBoolImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool value});
}

/// @nodoc
class __$$SuccessBoolImplCopyWithImpl<$Res>
    extends _$FhirliteSuccessCopyWithImpl<$Res, _$SuccessBoolImpl>
    implements _$$SuccessBoolImplCopyWith<$Res> {
  __$$SuccessBoolImplCopyWithImpl(
      _$SuccessBoolImpl _value, $Res Function(_$SuccessBoolImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SuccessBoolImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SuccessBoolImpl implements SuccessBool {
  const _$SuccessBoolImpl(this.value);

  @override
  final bool value;

  @override
  String toString() {
    return 'FhirliteSuccess.successBool(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessBoolImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessBoolImplCopyWith<_$SuccessBoolImpl> get copyWith =>
      __$$SuccessBoolImplCopyWithImpl<_$SuccessBoolImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() success,
    required TResult Function(String value) successString,
    required TResult Function(bool value) successBool,
    required TResult Function(NotificationResult value)
        successNotificationResult,
  }) {
    return successBool(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? success,
    TResult? Function(String value)? successString,
    TResult? Function(bool value)? successBool,
    TResult? Function(NotificationResult value)? successNotificationResult,
  }) {
    return successBool?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? success,
    TResult Function(String value)? successString,
    TResult Function(bool value)? successBool,
    TResult Function(NotificationResult value)? successNotificationResult,
    required TResult orElse(),
  }) {
    if (successBool != null) {
      return successBool(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Successful value) success,
    required TResult Function(SuccessString value) successString,
    required TResult Function(SuccessBool value) successBool,
    required TResult Function(SuccessNotificationResult value)
        successNotificationResult,
  }) {
    return successBool(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Successful value)? success,
    TResult? Function(SuccessString value)? successString,
    TResult? Function(SuccessBool value)? successBool,
    TResult? Function(SuccessNotificationResult value)?
        successNotificationResult,
  }) {
    return successBool?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Successful value)? success,
    TResult Function(SuccessString value)? successString,
    TResult Function(SuccessBool value)? successBool,
    TResult Function(SuccessNotificationResult value)?
        successNotificationResult,
    required TResult orElse(),
  }) {
    if (successBool != null) {
      return successBool(this);
    }
    return orElse();
  }
}

abstract class SuccessBool implements FhirliteSuccess {
  const factory SuccessBool(final bool value) = _$SuccessBoolImpl;

  bool get value;
  @JsonKey(ignore: true)
  _$$SuccessBoolImplCopyWith<_$SuccessBoolImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessNotificationResultImplCopyWith<$Res> {
  factory _$$SuccessNotificationResultImplCopyWith(
          _$SuccessNotificationResultImpl value,
          $Res Function(_$SuccessNotificationResultImpl) then) =
      __$$SuccessNotificationResultImplCopyWithImpl<$Res>;
  @useResult
  $Res call({NotificationResult value});
}

/// @nodoc
class __$$SuccessNotificationResultImplCopyWithImpl<$Res>
    extends _$FhirliteSuccessCopyWithImpl<$Res, _$SuccessNotificationResultImpl>
    implements _$$SuccessNotificationResultImplCopyWith<$Res> {
  __$$SuccessNotificationResultImplCopyWithImpl(
      _$SuccessNotificationResultImpl _value,
      $Res Function(_$SuccessNotificationResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SuccessNotificationResultImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as NotificationResult,
    ));
  }
}

/// @nodoc

class _$SuccessNotificationResultImpl implements SuccessNotificationResult {
  const _$SuccessNotificationResultImpl(this.value);

  @override
  final NotificationResult value;

  @override
  String toString() {
    return 'FhirliteSuccess.successNotificationResult(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessNotificationResultImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessNotificationResultImplCopyWith<_$SuccessNotificationResultImpl>
      get copyWith => __$$SuccessNotificationResultImplCopyWithImpl<
          _$SuccessNotificationResultImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() success,
    required TResult Function(String value) successString,
    required TResult Function(bool value) successBool,
    required TResult Function(NotificationResult value)
        successNotificationResult,
  }) {
    return successNotificationResult(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? success,
    TResult? Function(String value)? successString,
    TResult? Function(bool value)? successBool,
    TResult? Function(NotificationResult value)? successNotificationResult,
  }) {
    return successNotificationResult?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? success,
    TResult Function(String value)? successString,
    TResult Function(bool value)? successBool,
    TResult Function(NotificationResult value)? successNotificationResult,
    required TResult orElse(),
  }) {
    if (successNotificationResult != null) {
      return successNotificationResult(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Successful value) success,
    required TResult Function(SuccessString value) successString,
    required TResult Function(SuccessBool value) successBool,
    required TResult Function(SuccessNotificationResult value)
        successNotificationResult,
  }) {
    return successNotificationResult(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Successful value)? success,
    TResult? Function(SuccessString value)? successString,
    TResult? Function(SuccessBool value)? successBool,
    TResult? Function(SuccessNotificationResult value)?
        successNotificationResult,
  }) {
    return successNotificationResult?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Successful value)? success,
    TResult Function(SuccessString value)? successString,
    TResult Function(SuccessBool value)? successBool,
    TResult Function(SuccessNotificationResult value)?
        successNotificationResult,
    required TResult orElse(),
  }) {
    if (successNotificationResult != null) {
      return successNotificationResult(this);
    }
    return orElse();
  }
}

abstract class SuccessNotificationResult implements FhirliteSuccess {
  const factory SuccessNotificationResult(final NotificationResult value) =
      _$SuccessNotificationResultImpl;

  NotificationResult get value;
  @JsonKey(ignore: true)
  _$$SuccessNotificationResultImplCopyWith<_$SuccessNotificationResultImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FhirliteError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) failureMessage,
    required TResult Function(Object exception, StackTrace stackTrace)
        exception,
    required TResult Function(AtException exception, StackTrace stackTrace)
        atSign,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? failureMessage,
    TResult? Function(Object exception, StackTrace stackTrace)? exception,
    TResult? Function(AtException exception, StackTrace stackTrace)? atSign,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? failureMessage,
    TResult Function(Object exception, StackTrace stackTrace)? exception,
    TResult Function(AtException exception, StackTrace stackTrace)? atSign,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FailureMessageError value) failureMessage,
    required TResult Function(ExceptionError value) exception,
    required TResult Function(AtError value) atSign,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FailureMessageError value)? failureMessage,
    TResult? Function(ExceptionError value)? exception,
    TResult? Function(AtError value)? atSign,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FailureMessageError value)? failureMessage,
    TResult Function(ExceptionError value)? exception,
    TResult Function(AtError value)? atSign,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FhirliteErrorCopyWith<$Res> {
  factory $FhirliteErrorCopyWith(
          FhirliteError value, $Res Function(FhirliteError) then) =
      _$FhirliteErrorCopyWithImpl<$Res, FhirliteError>;
}

/// @nodoc
class _$FhirliteErrorCopyWithImpl<$Res, $Val extends FhirliteError>
    implements $FhirliteErrorCopyWith<$Res> {
  _$FhirliteErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FailureMessageErrorImplCopyWith<$Res> {
  factory _$$FailureMessageErrorImplCopyWith(_$FailureMessageErrorImpl value,
          $Res Function(_$FailureMessageErrorImpl) then) =
      __$$FailureMessageErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$FailureMessageErrorImplCopyWithImpl<$Res>
    extends _$FhirliteErrorCopyWithImpl<$Res, _$FailureMessageErrorImpl>
    implements _$$FailureMessageErrorImplCopyWith<$Res> {
  __$$FailureMessageErrorImplCopyWithImpl(_$FailureMessageErrorImpl _value,
      $Res Function(_$FailureMessageErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$FailureMessageErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FailureMessageErrorImpl implements FailureMessageError {
  const _$FailureMessageErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'FhirliteError.failureMessage(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FailureMessageErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FailureMessageErrorImplCopyWith<_$FailureMessageErrorImpl> get copyWith =>
      __$$FailureMessageErrorImplCopyWithImpl<_$FailureMessageErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) failureMessage,
    required TResult Function(Object exception, StackTrace stackTrace)
        exception,
    required TResult Function(AtException exception, StackTrace stackTrace)
        atSign,
  }) {
    return failureMessage(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? failureMessage,
    TResult? Function(Object exception, StackTrace stackTrace)? exception,
    TResult? Function(AtException exception, StackTrace stackTrace)? atSign,
  }) {
    return failureMessage?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? failureMessage,
    TResult Function(Object exception, StackTrace stackTrace)? exception,
    TResult Function(AtException exception, StackTrace stackTrace)? atSign,
    required TResult orElse(),
  }) {
    if (failureMessage != null) {
      return failureMessage(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FailureMessageError value) failureMessage,
    required TResult Function(ExceptionError value) exception,
    required TResult Function(AtError value) atSign,
  }) {
    return failureMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FailureMessageError value)? failureMessage,
    TResult? Function(ExceptionError value)? exception,
    TResult? Function(AtError value)? atSign,
  }) {
    return failureMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FailureMessageError value)? failureMessage,
    TResult Function(ExceptionError value)? exception,
    TResult Function(AtError value)? atSign,
    required TResult orElse(),
  }) {
    if (failureMessage != null) {
      return failureMessage(this);
    }
    return orElse();
  }
}

abstract class FailureMessageError implements FhirliteError {
  const factory FailureMessageError(final String message) =
      _$FailureMessageErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$FailureMessageErrorImplCopyWith<_$FailureMessageErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceptionErrorImplCopyWith<$Res> {
  factory _$$ExceptionErrorImplCopyWith(_$ExceptionErrorImpl value,
          $Res Function(_$ExceptionErrorImpl) then) =
      __$$ExceptionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object exception, StackTrace stackTrace});
}

/// @nodoc
class __$$ExceptionErrorImplCopyWithImpl<$Res>
    extends _$FhirliteErrorCopyWithImpl<$Res, _$ExceptionErrorImpl>
    implements _$$ExceptionErrorImplCopyWith<$Res> {
  __$$ExceptionErrorImplCopyWithImpl(
      _$ExceptionErrorImpl _value, $Res Function(_$ExceptionErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
  }) {
    return _then(_$ExceptionErrorImpl(
      null == exception ? _value.exception : exception,
      null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$ExceptionErrorImpl implements ExceptionError {
  const _$ExceptionErrorImpl(this.exception, this.stackTrace);

  @override
  final Object exception;
  @override
  final StackTrace stackTrace;

  @override
  String toString() {
    return 'FhirliteError.exception(exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceptionErrorImpl &&
            const DeepCollectionEquality().equals(other.exception, exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(exception), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExceptionErrorImplCopyWith<_$ExceptionErrorImpl> get copyWith =>
      __$$ExceptionErrorImplCopyWithImpl<_$ExceptionErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) failureMessage,
    required TResult Function(Object exception, StackTrace stackTrace)
        exception,
    required TResult Function(AtException exception, StackTrace stackTrace)
        atSign,
  }) {
    return exception(this.exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? failureMessage,
    TResult? Function(Object exception, StackTrace stackTrace)? exception,
    TResult? Function(AtException exception, StackTrace stackTrace)? atSign,
  }) {
    return exception?.call(this.exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? failureMessage,
    TResult Function(Object exception, StackTrace stackTrace)? exception,
    TResult Function(AtException exception, StackTrace stackTrace)? atSign,
    required TResult orElse(),
  }) {
    if (exception != null) {
      return exception(this.exception, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FailureMessageError value) failureMessage,
    required TResult Function(ExceptionError value) exception,
    required TResult Function(AtError value) atSign,
  }) {
    return exception(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FailureMessageError value)? failureMessage,
    TResult? Function(ExceptionError value)? exception,
    TResult? Function(AtError value)? atSign,
  }) {
    return exception?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FailureMessageError value)? failureMessage,
    TResult Function(ExceptionError value)? exception,
    TResult Function(AtError value)? atSign,
    required TResult orElse(),
  }) {
    if (exception != null) {
      return exception(this);
    }
    return orElse();
  }
}

abstract class ExceptionError implements FhirliteError {
  const factory ExceptionError(
          final Object exception, final StackTrace stackTrace) =
      _$ExceptionErrorImpl;

  Object get exception;
  StackTrace get stackTrace;
  @JsonKey(ignore: true)
  _$$ExceptionErrorImplCopyWith<_$ExceptionErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AtErrorImplCopyWith<$Res> {
  factory _$$AtErrorImplCopyWith(
          _$AtErrorImpl value, $Res Function(_$AtErrorImpl) then) =
      __$$AtErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AtException exception, StackTrace stackTrace});
}

/// @nodoc
class __$$AtErrorImplCopyWithImpl<$Res>
    extends _$FhirliteErrorCopyWithImpl<$Res, _$AtErrorImpl>
    implements _$$AtErrorImplCopyWith<$Res> {
  __$$AtErrorImplCopyWithImpl(
      _$AtErrorImpl _value, $Res Function(_$AtErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
    Object? stackTrace = null,
  }) {
    return _then(_$AtErrorImpl(
      null == exception
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as AtException,
      null == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

class _$AtErrorImpl implements AtError {
  const _$AtErrorImpl(this.exception, this.stackTrace);

  @override
  final AtException exception;
  @override
  final StackTrace stackTrace;

  @override
  String toString() {
    return 'FhirliteError.atSign(exception: $exception, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AtErrorImpl &&
            (identical(other.exception, exception) ||
                other.exception == exception) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, exception, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AtErrorImplCopyWith<_$AtErrorImpl> get copyWith =>
      __$$AtErrorImplCopyWithImpl<_$AtErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String message) failureMessage,
    required TResult Function(Object exception, StackTrace stackTrace)
        exception,
    required TResult Function(AtException exception, StackTrace stackTrace)
        atSign,
  }) {
    return atSign(this.exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String message)? failureMessage,
    TResult? Function(Object exception, StackTrace stackTrace)? exception,
    TResult? Function(AtException exception, StackTrace stackTrace)? atSign,
  }) {
    return atSign?.call(this.exception, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String message)? failureMessage,
    TResult Function(Object exception, StackTrace stackTrace)? exception,
    TResult Function(AtException exception, StackTrace stackTrace)? atSign,
    required TResult orElse(),
  }) {
    if (atSign != null) {
      return atSign(this.exception, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(FailureMessageError value) failureMessage,
    required TResult Function(ExceptionError value) exception,
    required TResult Function(AtError value) atSign,
  }) {
    return atSign(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(FailureMessageError value)? failureMessage,
    TResult? Function(ExceptionError value)? exception,
    TResult? Function(AtError value)? atSign,
  }) {
    return atSign?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(FailureMessageError value)? failureMessage,
    TResult Function(ExceptionError value)? exception,
    TResult Function(AtError value)? atSign,
    required TResult orElse(),
  }) {
    if (atSign != null) {
      return atSign(this);
    }
    return orElse();
  }
}

abstract class AtError implements FhirliteError {
  const factory AtError(
      final AtException exception, final StackTrace stackTrace) = _$AtErrorImpl;

  AtException get exception;
  StackTrace get stackTrace;
  @JsonKey(ignore: true)
  _$$AtErrorImplCopyWith<_$AtErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
